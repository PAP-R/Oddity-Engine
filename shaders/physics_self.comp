#version 450 core

#include <physics.comp>

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

mat4 transform(uint obj) {
//    vec3 position = objects[obj].position.xyz;
    vec3 position = vec3(0);
    vec4 q = objects[obj].orientation;

    return mat4(1 - 2 * (q.z * q.z + q.w * q.w), 2 * (q.y * q.z + q.w * q.x), 2 * (q.y * q.w - q.z * q.x), 0,
                2 * (q.y * q.z - q.w * q.x), 1 - 2 * (q.y * q.y + q.w * q.w), 2 * (q.z * q.w + q.y * q.x), 0,
                2 * (q.y * q.w + q.z * q.x), 2 * (q.z * q.w - q.y * q.x), 1 - 2 * (q.y * q.y + q.z * q.z), 0,
                position.x, position.y, position.z, 1);
}

void main() {
    uint self = gl_WorkGroupID.x;

    objects[self].state &= ~HIT;

//    if(isnan(length(objects[self].position)) || isnan(length(objects[self].velocity)) || isnan(length(objects[self].acceleration)) || isnan(length(objects[self].angle))) {
//        objects[self].state &= ~CLIP;
//        objects[self].state |= ERROR;
//    }

    if ((objects[self].state & MOVE) != 0) {

        float Air_Density = 1;

        vec3 v = objects[self].velocity.xyz;

        float c = QUARTER_PI * Air_Density * pow(objects[self].radius, 2);

        objects[self].acceleration.xyz -= c * v * abs(v);

        objects[self].velocity.xyz += objects[self].acceleration.xyz * time_delta * 0.5;
        objects[self].position.xyz += objects[self].velocity.xyz * time_delta;
        objects[self].velocity.xyz += objects[self].acceleration.xyz * time_delta * 0.5;

        objects[self].angle_velocity.xyz += objects[self].angle_acceleration.xyz * time_delta * 0.5;
        objects[self].angle.xyz += objects[self].angle_velocity.xyz * time_delta;
        objects[self].angle_velocity.xyz += objects[self].angle_acceleration.xyz * time_delta * 0.5;
    }

    objects[self].acceleration.xyz = vec3(0);

    objects[self].transform = transform(self);
    objects[self].inverse_transform = inverse(objects[self].transform);
}
