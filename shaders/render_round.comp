#version 450 core

#include <buffer.glsl>
#include <object.glsl>

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2DArray texture;

struct render_struct {
    vec4 camera_pos;
    mat4 vp;
    vec2 view_size;
    uint layer;
};

layout(std140, std430, binding = RENDER) buffer render_buffer {
    render_struct render;
};

vec3 FRONT_BASE = normalize(vec3(0, 0, -1));
vec3 LEFT = ((render.vp * vec4(normalize(vec3(-1, 0, 0) + FRONT_BASE), 1)).xyz);
vec3 RIGHT = ((render.vp * vec4(normalize(vec3(1, 0, 0) + FRONT_BASE), 1)).xyz);
vec3 DOWN = ((render.vp * vec4(normalize(vec3(0, -1, 0) + FRONT_BASE), 1)).xyz);
vec3 UP = ((render.vp * vec4(normalize(vec3(0, 1, 0) + FRONT_BASE), 1)).xyz);
vec3 FRONT = ((render.vp * vec4(FRONT_BASE, 1)).xyz);

ivec3 to_pixel(vec3 dir) {
    dir = normalize(dir);
    return ivec3(vec2(dot(dir - LEFT, normalize(RIGHT - LEFT)) / distance(LEFT, RIGHT), dot(dir - DOWN, normalize(UP - DOWN)) / distance(DOWN, UP)) * render.view_size, render.layer);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

int point_size = 250;

void main() {
    Object self = objects[gl_WorkGroupID.x];

    memoryBarrier();

    if ((self.state & SHOW) > 0) {
        uint steps = 128;
        float dist = distance(self.position.xyz, render.camera_pos.xyz);
        float step_size = 2 * PI / steps;

        for (float i = 0; i < 2 * PI; i += step_size) {
            for (int s = 0; s < 5; s++) {
                vec3 dir = FRONT + ((RIGHT - LEFT) / 2) * sin(i) + ((UP - DOWN) / 2) * cos(i);
                vec4 result = trace(render.camera_pos.xyz, dir, s, gl_WorkGroupID.x);
                ivec3 pixel = to_pixel(result.xyz);
                //            pixel.xy = clamp(pixel.xy, ivec2(0), ivec2(render.view_size.xy));

                if (0 <= pixel.x && pixel.x < render.view_size.x && 0 <= pixel.y && pixel.y < render.view_size.y) {
                    imageStore(texture, pixel, vec4(hsv2rgb(vec3(mod(result.w * gl_WorkGroupID.x / gl_NumWorkGroups.x, 1), 1, 1)), 1));
                }
            }
        }


//        vec3 dir = self.position.xyz - render.camera_pos.xyz;
//        if (dot(dir, FRONT) > 0) {
//            float radius = self.radius;
//
//            float len = length(dir);
//
//            ivec3 center = to_pixel(dir);
//
//            int size = int(radius / len);
//
//            if (center.z >= 0) {
//                for (int x = -size; x <= size; x++) {
//                    int circle = size - abs(int(size * cos(asin(float(x) / size))));
//                    for (int y = -size + circle; y <= size - circle; y++) {
//                        ivec3 pixel = center + ivec3(x, y, 0);
//                        if (0 <= pixel.x && pixel.x < render.view_size.x && 0 <= pixel.y && pixel.y < render.view_size.y) {
//                            imageStore(texture, pixel, vec4(vec2(pixel.xy) / render.view_size.xy, 0, 1));
//                        }
//                    }
//                }
//            }
//        }
    }
    memoryBarrier();
}
