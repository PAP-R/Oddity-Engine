#version 450 core

#include <buffer.glsl>
#include <object.glsl>

#define G 0.0001
#define Gravity 9.81f
#define Air_Density 1.0f
#define TOLERANCE 1E-3

#define PI 3.1415926535897932384626433832795

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std140, std430, binding = PHYSICS) buffer time_buffer {
    float time_delta;
    float self_f;
    float other_f;
};

void main() {
    uint self = gl_WorkGroupID.x;
    uint other = gl_WorkGroupID.y;

//    uint self = uint(self_f);
//    uint other = uint(other_f);

    barrier();

    Object delta = make_empty_object();
    Object delta_other = make_empty_object();

    if (self == other) {
        objects[self].state &= ~HIT;
//        objects[self].state |= HIT;

        bool on_ground = objects[self].position.y < 0;

        vec3 v = objects[self].velocity.xyz;
        float Cd = 5;

        float A = PI * pow(objects[self].test_value.x, 2);

        objects[self].acceleration.xyz -= Cd * (Air_Density * v * abs(v)) / 2 * A;


        objects[self].velocity.xyz += objects[self].acceleration.xyz * time_delta / 2;
        objects[self].position.xyz += objects[self].velocity.xyz * time_delta;
        objects[self].velocity.xyz += objects[self].acceleration.xyz * time_delta / 2;

        objects[self].angle_velocity.xyz += objects[self].angle_acceleration.xyz * time_delta / 2;
        objects[self].angle.xyz += objects[self].angle_velocity.xyz * time_delta;
        objects[self].angle_velocity.xyz += objects[self].angle_acceleration.xyz * time_delta / 2;

        objects[self].acceleration.xyz = vec3(0);

        barrier();
    }
    else if (self < other){
        barrier();

        vec3 inner = objects[other].position.xyz - objects[self].position.xyz;
        vec3 outer = closest_point(objects[self].position.xyz, other) - closest_point(objects[other].position.xyz, self);

        if (self == 1) {
            objects[self].test_value.w = length(outer) * (objects[other].mass / (objects[self].mass + objects[other].mass));
            objects[other].test_value.w = length(outer) * (objects[self].mass / (objects[self].mass + objects[other].mass));
        }

        if (length(outer) != 0 && dot(inner, outer) < 0) {
            vec3 normal = normalize(inner);

            float mass = 1 / ((1 / objects[self].mass) + (1 / objects[other].mass));

            vec3 impact_velocity = normal * (objects[self].velocity.xyz - objects[other].velocity.xyz);

            float e = (objects[self].restitution + objects[other].restitution) / 2;

            vec3 impulse = e * mass * impact_velocity;

            delta.velocity.xyz = - impulse * normal / objects[self].mass;

            delta_other.velocity.xyz = + impulse * normal / objects[other].mass;

            vec3 dist = outer;

            delta.position.xyz = dist * (objects[other].mass / (objects[self].mass + objects[other].mass));
            delta_other.position.xyz = -dist * (objects[self].mass / (objects[self].mass + objects[other].mass));

            delta.state |= HIT;
            delta_other.state |= HIT;
        }
        else {
            delta.acceleration.xyz = G * normalize(inner) * objects[other].mass / pow(length(inner) + 1, 2);
            delta_other.acceleration.xyz = -G * normalize(inner) * objects[self].mass / pow(length(inner) + 1, 2);
        }
    }
    else {
        barrier();
    }

    barrier();

    const uint value_count = 7;

    for (uint block = 0; block < gl_NumWorkGroups.y; block += value_count) {
        for (uint x = 0; x < value_count; x++) {
            if (x + block == other) {
                objects[self].position.xyz += delta.position.xyz;
            }
            else if ((x + 1) % value_count + block == other) {
                objects[self].velocity.xyz += delta.velocity.xyz;
            }
            else if ((x + 2) % value_count + block == other) {
                objects[self].acceleration.xyz += delta.acceleration.xyz;
            }
            else if ((x + 3) % value_count + block == other) {
                objects[self].angle.xyz += delta.angle.xyz;
            }
            else if ((x + 4) % value_count + block == other) {
                objects[self].angle_velocity.xyz += delta.angle_velocity.xyz;
            }
            else if ((x + 5) % value_count + block == other) {
                objects[self].angle_acceleration.xyz += delta.angle_acceleration.xyz;
            }
            else if ((x + 6) % value_count + block == other) {
                objects[self].state |= (delta.state & HIT);
            }

            barrier();

            if (self != other && x + block == self) {
                objects[other].state |= (delta_other.state & HIT);

                objects[other].position.xyz += delta_other.position.xyz;
                objects[other].velocity.xyz += delta_other.velocity.xyz;
                objects[other].acceleration.xyz += delta_other.acceleration.xyz;
            }

            barrier();
        }
    }
}
