#version 450 core

#include <buffer.glsl>
#include <object.glsl>

#define G 0.1
#define Gravity 9.81f
#define Air_Density 1.0f

#define PI 3.1415926535897932384626433832795

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std140, std430, binding = TIME) buffer time_buffer {
    float time_delta;
};

shared Object self_object;

void main() {
    uint self = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x;
    uint other = gl_WorkGroupID.y + gl_WorkGroupID.y * gl_NumWorkGroups.y;

    barrier();

    if (self == other) {
        self_object = objects[self];
        barrier();
        bool on_ground = objects[self].position.y < 0;

        vec3 v = objects[self].velocity.xyz;
        float Cd = 5;

        float A = PI * pow(objects[self].test_value.x, 2);

        vec3 D = Cd * (Air_Density * v * abs(v)) / 2 * A;



        objects[self].velocity.xyz += objects[self].acceleration.xyz * time_delta / 2;
        objects[self].position.xyz += objects[self].velocity.xyz * time_delta;
        objects[self].velocity.xyz += objects[self].acceleration.xyz * time_delta / 2;

        objects[self].angle_velocity.xyz += objects[self].angle_acceleration.xyz * time_delta / 2;
        objects[self].angle.xyz += objects[self].angle_velocity.xyz * time_delta;
        objects[self].angle_velocity.xyz += objects[self].angle_acceleration.xyz * time_delta / 2;
        barrier();

        uint set_self = gl_WorkGroupID.x;
        for (uint i = 1; i < gl_NumWorkGroups.y; i++) {
            objects[set_self].position.xyz += objects[set_self + i * gl_NumWorkGroups.y].position.xyz;
            objects[set_self].velocity.xyz += objects[set_self + i * gl_NumWorkGroups.y].velocity.xyz;
            objects[set_self].acceleration.xyz += objects[set_self + i * gl_NumWorkGroups.y].acceleration.xyz;

            objects[set_self].angle.xyz += objects[set_self + i * gl_NumWorkGroups.y].angle.xyz;
            objects[set_self].angle_velocity.xyz += objects[set_self + i * gl_NumWorkGroups.y].angle_velocity.xyz;
            objects[set_self].angle_acceleration.xyz += objects[set_self + i * gl_NumWorkGroups.y].angle_acceleration.xyz;
        }

        objects[set_self].position.xyz /= gl_NumWorkGroups.y;
        objects[set_self].velocity.xyz /= gl_NumWorkGroups.y;
        objects[set_self].acceleration.xyz /= gl_NumWorkGroups.y;

        objects[set_self].angle.xyz /= gl_NumWorkGroups.y;
        objects[set_self].angle_velocity.xyz /= gl_NumWorkGroups.y;
        objects[set_self].angle_acceleration.xyz /= gl_NumWorkGroups.y;
    }
    else {
        barrier();
        vec3 to_other = objects[other].position.xyz - objects[self].position.xyz;
        objects[self].acceleration.xyz += G * normalize(to_other) * objects[other].mass / pow(length(to_other), 2);
        barrier();

        if (length(to_other) < (objects[self].test_value.x + objects[other].test_value.x)) {
            objects[self].position.xyz += normalize(to_other) * (length(to_other) - (objects[self].test_value.x + objects[other].test_value.x));

            objects[self].velocity.xyz = (objects[self].mass - objects[other].mass) / (objects[self].mass + objects[other].mass) * objects[self].velocity.xyz + (2 * objects[other].mass) / (objects[self].mass + objects[other].mass) * objects[other].velocity.xyz;
            objects[self].acceleration.xyz *= 0;
        }

        barrier();
    }
}
