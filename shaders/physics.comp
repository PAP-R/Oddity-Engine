#version 450 core

#include <buffer.glsl>
#include <object.glsl>

#define G 0.00001
#define Gravity 9.81f
#define Air_Density 1.0f

#define PI 3.1415926535897932384626433832795

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std140, std430, binding = TIME) buffer time_buffer {
    float time_delta;
};

void main() {
    uint self = gl_WorkGroupID.x;
    uint other = gl_WorkGroupID.y;

    barrier();

    Object delta;
    Object delta_other;

    if (self == other) {
        objects[self].state &= ~HIT;

        bool on_ground = objects[self].position.y < 0;

        vec3 v = objects[self].velocity.xyz;
        float Cd = 5;

        float A = PI * pow(objects[self].test_value.x, 2);

        vec3 D = Cd * (Air_Density * v * abs(v)) / 2 * A;


        objects[self].velocity.xyz += objects[self].acceleration.xyz * time_delta / 2;
        objects[self].position.xyz += objects[self].velocity.xyz * time_delta;
        objects[self].velocity.xyz += objects[self].acceleration.xyz * time_delta / 2;

        objects[self].angle_velocity.xyz += objects[self].angle_acceleration.xyz * time_delta / 2;
        objects[self].angle.xyz += objects[self].angle_velocity.xyz * time_delta;
        objects[self].angle_velocity.xyz += objects[self].angle_acceleration.xyz * time_delta / 2;
        memoryBarrier();
    }
    else if (self < other){
        memoryBarrier();
        vec3 inner = objects[other].position.xyz - objects[self].position.xyz;
        vec3 outer = closest(objects[self].position.xyz, other) - closest(objects[other].position.xyz, self);

        if (length(inner) >= length(outer)) {
            vec3 normal = normalize(outer);

            float mass = 1 / (1 / objects[self].mass + 1 / objects[other].mass);

            vec3 impact_velocity = normal * (objects[self].velocity.xyz - objects[other].velocity.xyz);

            float e = (objects[self].restitution + objects[other].restitution) / 2;

            vec3 impulse = (1 + e) * mass * impact_velocity;

            delta.velocity.xyz = - impulse / objects[self].mass * normal;

            delta_other.velocity.xyz = + impulse / objects[other].mass * normal;

            vec3 dist = (outer - inner) * time_delta;

            delta.position.xyz = dist * (objects[other].mass / (objects[self].mass + objects[other].mass));
            delta_other.position.xyz = -dist * (objects[self].mass / (objects[self].mass + objects[other].mass));

            delta.state |= HIT;
            objects[self].state |= HIT;
            objects[other].state |= HIT;
        }
        else {
            delta.acceleration.xyz = G * normalize(inner) * objects[other].mass / pow(length(inner), 2);
            delta_other.acceleration.xyz = -G * normalize(inner) * objects[self].mass / pow(length(inner), 2);
        }
    }

    memoryBarrier();

    if (self == other && (objects[self].state & HIT) > 0) {
        objects[self].acceleration.xyz = vec3(0);
    }

    memoryBarrier();

    uint value_count = 6;

    for (uint y = 0; y < gl_NumWorkGroups.y; y += value_count) {
        for (uint x = 0; x < value_count; x++) {
            if (x + y == other) {
                objects[self].position.xyz += delta.position.xyz;
            }
            else if ((x + 1) % value_count + y == other) {
                objects[self].velocity.xyz += delta.velocity.xyz;
            }
            else if ((x + 2) % value_count == other) {
                objects[self].acceleration.xyz += delta.acceleration.xyz;
            }
            else if ((x + 3) % value_count == other) {
                objects[self].angle.xyz += delta.angle.xyz;
            }
            else if ((x + 4) % value_count + y == other && (delta.state & HIT) > 0) {
                objects[self].angle_velocity.xyz = (objects[self].angle_velocity.xyz + delta.angle_velocity.xyz) / 2;
            }
            else if ((x + 5) % value_count == other) {
                objects[self].angle_acceleration.xyz += delta.angle_acceleration.xyz;
            }

            memoryBarrier();

            if (self != other && x + y == self) {
                objects[other].position.xyz += delta_other.position.xyz;
                objects[other].velocity.xyz += delta_other.velocity.xyz;
                objects[other].acceleration.xyz += delta_other.acceleration.xyz;
            }

            memoryBarrier();
        }
    }

    memoryBarrier();
}
