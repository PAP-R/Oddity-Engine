#version 450 core

#include <physics.comp>

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint self = gl_WorkGroupID.x;
    uint other = gl_WorkGroupID.y;

    uint self_write = other + self * gl_NumWorkGroups.x;
    uint other_write = self + other * gl_NumWorkGroups.x;

    if (self < other){
        vec3 inner = objects[other].position.xyz - objects[self].position.xyz;
        vec3 outer = closest_point(objects[self].position.xyz, other) - closest_point(objects[other].position.xyz, self);

        if (length(outer) != 0 && dot(inner, outer) < 0) {
            vec3 normal = normalize(inner);

            float mass = 1 / ((1 / objects[self].mass) + (1 / objects[other].mass));

            vec3 impact_velocity = normal * (objects[self].velocity.xyz - objects[other].velocity.xyz);

            float e = (objects[self].restitution + objects[other].restitution) / 2;

            vec3 impulse = e * mass * impact_velocity;

            temp_objects[self_write].velocity.xyz = - impulse * normal / objects[self].mass;

            temp_objects[other_write].velocity.xyz = + impulse * normal / objects[other].mass;

            vec3 dist = outer;

            temp_objects[self_write].position.xyz = dist * (objects[other].mass / (objects[self].mass + objects[other].mass));
            temp_objects[other_write].position.xyz = -dist * (objects[self].mass / (objects[self].mass + objects[other].mass));

            temp_objects[self_write].state |= HIT;
            temp_objects[other_write].state |= HIT;
        }
        else {
            temp_objects[self_write].acceleration.xyz = G * normalize(inner) * objects[other].mass / pow(max(length(inner), 1), 2);
            temp_objects[other_write].acceleration.xyz = -G * normalize(inner) * objects[self].mass / pow(max(length(inner), 1), 2);
        }
    }
}
