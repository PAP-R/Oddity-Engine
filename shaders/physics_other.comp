#version 450 core

#include <physics.comp>
#include <object_trace.glsl>

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void reset(uint index) {
    temp_objects[index].position.xyz = vec3(0);
    temp_objects[index].velocity.xyz = vec3(0);
    temp_objects[index].acceleration.xyz = vec3(0);

    temp_objects[index].angle.xyz = vec3(0);
    temp_objects[index].angle_velocity.xyz = vec3(0);
    temp_objects[index].angle_acceleration.xyz = vec3(0);

    for (uint j = 0; j < 10; j++) {
        temp_objects[index].test_value[j] = 0;
    }

    temp_objects[index].state = 0;
}

void main() {
    uint self = gl_WorkGroupID.x;
    uint other = gl_WorkGroupID.y;

    uint self_write = other + self * gl_NumWorkGroups.x;
    uint other_write = self + other * gl_NumWorkGroups.x;

    reset(self_write);
    reset(other_write);

    if (self < other && (objects[self].state & CLIP) > 0 && (objects[other].state & CLIP) > 0) {
        vec3 inner = objects[other].position.xyz - objects[self].position.xyz;

        trace_result closest_result = closest(objects[self].position.xyz, other);

        for (uint i = 0; i < 5; i++) {
            trace_result closest_temp = closest(closest_result.position, self);
            closest_result = closest(closest_temp.position, other);
        }

        if (closest_result.distance < 0) {
            vec3 normal = normalize(inner);

            float mass = 1 / ((1 / objects[self].mass) + (1 / objects[other].mass));

            vec3 impact_velocity = normal * (objects[self].velocity.xyz - objects[other].velocity.xyz);

            float e = (objects[self].restitution + objects[other].restitution) / 2;

            vec3 impulse = e * mass * impact_velocity;

            vec3 dist = closest_result.diff;

            if ((objects[self].state & MOVE) != 0) {
                temp_objects[self_write].position.xyz = + dist * (objects[other].mass / (objects[self].mass + objects[other].mass));
                temp_objects[self_write].velocity.xyz = - impulse * normal / objects[self].mass;
            }

            if ((objects[other].state & MOVE) != 0) {
                temp_objects[other_write].position.xyz = - dist * (objects[self].mass / (objects[self].mass + objects[other].mass));
                temp_objects[other_write].velocity.xyz = + impulse * normal / objects[other].mass;
            }

            temp_objects[self_write].state |= HIT;
            temp_objects[other_write].state |= HIT;
        }
        else if ((objects[self].state & CLIP) != 0 && (objects[other].state & CLIP) != 0) {
            if ((objects[self].state & MOVE) != 0) {
                temp_objects[self_write].acceleration.xyz = G * normalize(inner) * objects[self].mass * objects[other].mass / pow(max(length(inner), 1), 2);
                //                temp_objects[self_write].acceleration.xyz = G * normalize(inner) * objects[other].mass / pow(max(length(inner), 1), 2);
            }

            if ((objects[other].state & MOVE) != 0) {
                temp_objects[other_write].acceleration.xyz = -G * normalize(inner) * objects[self].mass * objects[other].mass / pow(max(length(inner), 1), 2);
                //                temp_objects[other_write].acceleration.xyz = -G * normalize(inner) * objects[self].mass / pow(max(length(inner), 1), 2);
            }
        }
    }
}
