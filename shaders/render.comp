#version 450 core

#include <buffer.glsl>
#include <object.glsl>

#define PI 3.1415926535897932384626433832795

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2DArray texture;

struct render_struct {
    vec4 camera_pos;
    mat4 vp;
    vec2 view_size;
    uint layer;
};

layout(std140, std430, binding = RENDER) buffer render_buffer {
    render_struct render;
};

vec3 FRONT_BASE = normalize(vec3(0, 0, -1));
vec3 LEFT = normalize((render.vp * vec4(normalize(vec3(-1, 0, 0) + FRONT_BASE), 1)).xyz);
vec3 RIGHT = normalize((render.vp * vec4(normalize(vec3(1, 0, 0) + FRONT_BASE), 1)).xyz);
vec3 DOWN = normalize((render.vp * vec4(normalize(vec3(0, -1, 0) + FRONT_BASE), 1)).xyz);
vec3 UP = normalize((render.vp * vec4(normalize(vec3(0, 1, 0) + FRONT_BASE), 1)).xyz);
vec3 FRONT = normalize((render.vp * vec4(FRONT_BASE, 1)).xyz);

ivec3 to_pixel(vec3 dir) {
    dir = normalize(dir);
//    ivec3 result = ivec3(vec2(acos(dot(dir, LEFT)) / (acos(dot(dir, LEFT)) + acos(dot(dir, RIGHT))), acos(dot(dir, DOWN)) / (acos(dot(dir, DOWN)) + acos(dot(dir, UP)))) * render.view_size, render.layer);
//    vec2 screen_percent = vec2(length(dir - LEFT) / (length(dir - LEFT) + length(dir - RIGHT)), length(dir - DOWN) / (length(dir - DOWN) + length(dir - UP)));
//    vec2 screen_percent = vec2(1 - length(((RIGHT - dir) * RIGHT) / (RIGHT - LEFT)), 1 - length(((UP - dir) * UP) / (UP - DOWN)));
    vec2 screen_percent = vec2(dot(dir - LEFT, normalize(RIGHT - LEFT)) / distance(LEFT, RIGHT), dot(dir - DOWN, normalize(UP - DOWN)) / distance(DOWN, UP));
    if (0 <= screen_percent.x && screen_percent.x < 1 && 0 <= screen_percent.y && screen_percent.y < 1) {
        return ivec3(screen_percent * render.view_size, render.layer);
    }
    else {
        return ivec3(0, 0, -1);
    }
}

int point_size = 250;

void main() {
    Object self = objects[gl_WorkGroupID.x];

    if ((self.state & NO_SHOW) == 0) {
        vec3 dir = self.position.xyz - render.camera_pos.xyz;

        float radius = self.test_value.x;

        ivec3 left_pixel = to_pixel(dir + radius * LEFT);
        ivec3 right_pixel = to_pixel(dir + radius * RIGHT);
        ivec3 down_pixel = to_pixel(dir + radius * DOWN);
        ivec3 up_pixel = to_pixel(dir + radius * UP);

        int left = int(clamp(left_pixel.x, 0, render.view_size.x - 1));
        int right = int(clamp(right_pixel.x, 0, render.view_size.x));
        int down = int(clamp(down_pixel.y, 0, render.view_size.y - 1));
        int up = int(clamp(up_pixel.y, 0, render.view_size.y));

        ivec3 center = to_pixel(dir);

        int point_width = (right - left) / 2;
        int point_height = (up - down) / 2;

        int horizenter = (left + right) / 2;

        if (center.z >= 0) {
            for (int x = left; x < right; x++) {
                int circle = point_height - abs(int(point_height * cos(asin(float(x - horizenter) / point_width))));
                for (int y = down + circle; y <= up - circle; y++) {
                    ivec3 pixel = ivec3(x, y, center.z);
                    if (0 <= pixel.x && pixel.x < render.view_size.x && 0 <= pixel.y && pixel.y < render.view_size.y) {
                        imageStore(texture, pixel, vec4(vec2(pixel.xy) / render.view_size.xy, 0, 1));
                    }
                }
            }
        }
    }
    barrier();
}
