#version 450 core

#include <buffer.glsl>
#include <object.glsl>
#include <object_trace.glsl>

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2DArray texture;

layout(std140, std430, binding = RENDER) buffer render_buffer {
    vec4 camera_pos;
    mat4 vp;
    ivec2 view_size;
    uint layer;
};


vec3 projection(vec3 a, vec3 b) {
    return dot(a, normalize(b)) * b;
}

vec3 rejection(vec3 a, vec3 b) {
    return a - projection(a, b);
}

vec3 rejection_flat(vec3 a, vec3 b) {
    b = normalize(b);
    return rejection(a, b) / length(projection(a, b));
}


ivec2 view_center = view_size / 2;

vec3 NORTH = normalize(vec3(0, 0, -1));
vec4 FRONT_BASE = vp * vec4(NORTH, 1);
vec3 FRONT = ((vp * vec4(NORTH, 1)).xyz);
//vec3 FRONT = FRONT_BASE.xyz / FRONT_BASE.w;

vec4 LEFT_BASE = vp * vec4(normalize(vec3(-1, 0, 0) + NORTH), 1);
vec3 LEFT = normalize((vp * vec4(normalize(vec3(-1, 0, 0) + NORTH), 1)).xyz);
//vec3 LEFT = LEFT_BASE.xyz / LEFT_BASE.w;
vec3 TO_LEFT = rejection_flat(LEFT, FRONT);
vec3 TO_LEFT_DIR = normalize(TO_LEFT);
float LEFT_ANGLE = dot(LEFT, FRONT);

vec4 RIGHT_BASE = vp * vec4(normalize(vec3(1, 0, 0) + NORTH), 1);
vec3 RIGHT = normalize((vp * vec4(normalize(vec3(1, 0, 0) + NORTH), 1)).xyz);
//vec3 RIGHT = RIGHT_BASE.xyz / RIGHT_BASE.w;
vec3 TO_RIGHT = rejection_flat(RIGHT, FRONT);
vec3 TO_RIGHT_DIR = normalize(TO_RIGHT);
float RIGHT_ANGLE = dot(RIGHT, FRONT);

vec4 DOWN_BASE = vp * vec4(normalize(vec3(0, -1, 0) + NORTH), 1);
vec3 DOWN = normalize((vp * vec4(normalize(vec3(0, -1, 0) + NORTH), 1)).xyz);
//vec3 DOWN = DOWN_BASE.xyz / DOWN_BASE.w;
vec3 TO_DOWN = rejection_flat(DOWN, FRONT);
vec3 TO_DOWN_DIR = normalize(TO_DOWN);
float DOWN_ANGLE = dot(DOWN, FRONT);

vec4 UP_BASE = vp * vec4(normalize(vec3(0, 1, 0) + NORTH), 1);
vec3 UP = normalize((vp * vec4(normalize(vec3(0, 1, 0) + NORTH), 1)).xyz);
//vec3 UP = UP_BASE.xyz / UP_BASE.w;
vec3 TO_UP = rejection_flat(UP, FRONT);
vec3 TO_UP_DIR = normalize(TO_UP);
float UP_ANGLE = dot(UP, FRONT);


ivec2 dir_to_pixel(vec3 dir) {
    float center_angle = dot(dir, normalize(FRONT));

    vec3 to_dir = rejection_flat(dir, FRONT);

    vec3 dir_right = rejection(to_dir, normalize(TO_UP));
    vec3 dir_up = rejection(to_dir, normalize(TO_RIGHT));

    vec2 ratio = vec2(dot(dir_right, normalize(TO_RIGHT)) / length(TO_RIGHT), dot(dir_up, normalize(TO_UP)) / length(TO_UP));

    ivec2 from_center = ivec2(ratio * view_center);

    if (center_angle < 0) {
        from_center += ivec2(sign(ratio) * view_center);
    }

    return view_center + from_center;
}

vec3 pixel_to_dir(ivec2 pixel) {
    vec2 ratio = (pixel - view_center) / view_center;

    return normalize(FRONT + TO_RIGHT * ratio.x + TO_UP * ratio.y);
}

vec3 pixel_step_size = vec3((1 / view_center.x) * TO_RIGHT + (1 / view_center.y) * TO_UP);

vec3 hsv2rgb(float h, float s, float v) {
    vec3 c = vec3(h, s, v);
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void draw_point(ivec2 pos, vec4 color) {
    if (0 <= pos.x && pos.x < view_size.x && 0 <= pos.y && pos.y < view_size.y) {
        imageStore(texture, ivec3(pos, layer), color);
    }
}

void draw_relative_point(vec3 pos, vec4 color) {
    draw_point(dir_to_pixel(pos), color);
}

void draw_world_point(vec3 pos, vec4 color) {
    draw_point(dir_to_pixel(pos - camera_pos.xyz), color);
}

void draw_line(ivec2 start, ivec2 end) {
    vec2 p = start;

    vec2 d = end - p;

    float N = max(abs(d.x), abs(d.y));

    vec2 s = d / N;

    for (float i = 0; i <= N; i++) {
        draw_point(ivec2(p + s * i), vec4(hsv2rgb(i / N, 1, 1), 1));
    }
}

void draw_arc(ivec2 start, ivec2 start_dir, ivec2 end, ivec2 end_dir) {
    float dist = distance(start, end);
    vec2 dir = normalize(vec2(end - start));

    for (float t = 0; t <= 1; t += 0.02) {
        draw_point(ivec2(((1 - t) * ((1 - t) * start + (start_dir * t)) + t * (t * end + ((1 - t) * end_dir)))), vec4(hsv2rgb(t, 1, 1), 1));
        ivec2 point = ivec2((1 - t) * ((1 - t) * start + 0 * start_dir) + t * (t * end + (0) * end_dir));
        draw_point(point, vec4(hsv2rgb(t, 0, 1), 1));
    }

//    vec2 center = (start + end) / 2 + normalize(cross(start_dir, end_dir)) * distance(start, end) / 2;

    for (float t = 0; t <= 1; t += 0.01) {
        draw_point(ivec2((start + (dir * t * dist) + start_dir * (1 - t)) + (end_dir * t)), vec4(hsv2rgb(t, 1, 1), 1));
        ivec2 point = ivec2((1 - t) * (start + t * start_dir) + t * (end + (1 - t) * end_dir));
        draw_point(point, vec4(hsv2rgb(t, 1, 1), 1));
    }
}

void draw_world_line(vec3 start, vec3 end) {
    draw_line(dir_to_pixel(start - camera_pos.xyz), dir_to_pixel(end - camera_pos.xyz));
}

void draw_world_arc(vec3 start, vec3 start_dir, vec3 end, vec3 end_dir) {
    vec3 center = (start + end) / 2 + normalize(cross(start_dir, end_dir)) * distance(start, end) / 2;

    float radius = distance(start, center);

    float angle = acos(dot(normalize(start_dir), normalize(end_dir)));

    vec3 last = start;

    float step_size = 0.1;

    for (float t = step_size; t <= 1; t += step_size) {
        float current_angle = angle * t;

        vec3 current = center + vec3(radius * cos(current_angle), radius * sin(current_angle), 0);

        draw_world_line(last, current);

        last = current;
    }
}

vec3 fibonacci_sphere(uint i, uint count) {
    float phi = PI * (sqrt(5.) - 1.);

    float y = 1 - (i / float(count - 1)) * 2;

    float radius = sqrt(1 - y * y);

    float theta = phi * i;

    float x = cos(theta) * radius;
    float z = sin(theta) * radius;

    return vec3(x, y, z);
}

float line_step = 0.01;

void draw(uint obj, vec4 color) {
//    uint point_count = 1000;
//    point_count = min(point_count, uint(point_count * objects[obj].radius / distance(objects[obj].position.xyz, camera_pos.xyz)));
//
//    for (uint i = 0; i < point_count; i++) {
//        vec3 point = fibonacci_sphere(i, point_count);
//        vec3 origin = objects[obj].position.xyz + point * objects[obj].radius * 2;
//        vec4 result = trace_point(origin, -point, 5, obj);
//
////        vec4 result = trace_point(objects[obj].position.xyz, point, 5, obj);
//
//        draw_world_point(result.xyz, vec4(hsv2rgb(i / float(point_count), 1, 1), 0.5));
//    }


    uint steps = 360;
    steps = uint(min(steps, steps / distance(objects[obj].position.xyz, camera_pos.xyz)));

    float max_steps = 2 * PI;
    float step_size = max_steps / steps;

    float radius = length(TO_RIGHT + TO_UP);

    uint smoothing_steps = 10;

    for (float i = 0; i < max_steps; i += step_size) {
        vec3 dir = vec3(FRONT + (TO_UP_DIR * sin(i) + TO_RIGHT_DIR * cos(i)) * radius);

        trace_result result;

        for (uint s = 0; s < smoothing_steps; s++) {
            draw_relative_point(dir + result.diff, vec4(hsv2rgb(1 - i / max_steps, 0.5, 1), 1));

            trace_result temp_result = trace(camera_pos.xyz, dir + result.diff, smoothing_steps, obj);

            if (temp_result.distance >= TOLERANCE) {
                break;
            }

            result = temp_result;

            draw_relative_point(result.diff, vec4(hsv2rgb(i / max_steps, 0.5 + result.distance, 0.5 + result.distance), 1));
        }
    }

    vec3 center_dir = objects[obj].position.xyz - camera_pos.xyz;

    ivec2 center_pixel = dir_to_pixel(center_dir);

    draw_relative_point(center_dir, vec4(hsv2rgb(float(obj) / gl_NumWorkGroups.x, 1, 1), 1));
    draw_point(center_pixel, vec4(hsv2rgb(float(obj) / gl_NumWorkGroups.x, 1, 1), 1));

    steps = 4;
    steps = uint(min(steps, steps / distance(objects[obj].position.xyz, camera_pos.xyz)));

    step_size = max_steps / steps;

    for (float i = 0; i < max_steps; i += step_size) {
        vec2 p = center_pixel;

        vec2 d = vec2(sin(i), cos(i));

        float N = max(abs(d.x), abs(d.y));

        vec2 s = d / N;

        trace_result result;

        uint c = 1;

        do {
            p += s;
            result = trace(camera_pos.xyz, pixel_to_dir(ivec2(p)), 5, obj);
            draw_point(ivec2(p), vec4(hsv2rgb(i, 1, 1), 1));
            c++;
        } while(result.distance < TOLERANCE && abs(p.x - view_center.x) <= view_center.x && abs(p.y - view_center.y) <= view_center.y && c < 100);
    }

//    vec3 center_dir = objects[obj].position.xyz - camera_pos.xyz;
//    vec4 result = trace(camera_pos.xyz, center_dir, 2, obj);
//    draw_relative_point(result.xyz, color);
//
//    vec3 para = normalize(cross(center_dir, UP));
//    vec3 patam = normalize(cross(center_dir, para));
//
//    for (float i = 0; i < 2 * PI; i += step_size) {
//
//        vec3 trace_dir = normalize(FRONT + UP * sin(i) + RIGHT * cos(i));
//
//        for (uint s = 0; s < 4; s++) {
//            result = trace(camera_pos.xyz, trace_dir, 5, obj);
//
//            draw_relative_point(result.xyz, vec4(hsv2rgb(result.w, 1, 1), 1));
//
//            trace_dir += result.xyz * 0.1;
//        }
//    }

//    for (float i = 0; i < 2 * PI; i += step_size) {
//
//        float dist = length(center_dir);
//
//        for (uint s = 0; s < 10; s++) {
//
//            vec3 spup = normalize((para) * sin(i) + (patam) * cos(i));
//            vec4 resulte = closest_point(spup + objects[obj].position.xyz, obj);
////            vec4 resulte = trace_point(camera_pos.xyz, spup + objects[obj].position.xyz, 2, obj);
//
//            dist -= resulte.w / 2;
//
//            draw_world_point(resulte.xyz, color);
//        }
//
//        //            vec3 dir = normalize(center_dir + FRONT + (TO_RIGHT) * sin(i) + (TO_UP) * cos(i));
//        //            result = trace(camera_pos.xyz, dir, 4, gl_WorkGroupID.x);
//        //
//        //            draw_relative_point(result.xyz, vec4(hsv2rgb(mod(length(result.xyz) / length(center_dir), 1), 0.5, 1)), 1));
//
//    }

}

void draw_connection(uint start, uint end) {
    uint count = end - start + 1;

    vec3 center_dir;

    for (uint i = 0; i < count; i++) {
//        draw_world_line(objects[start + i].position.xyz, objects[start + (i + 1) % count].position.xyz);
//
//        draw_world_arc(objects[start + i].position.xyz, objects[start + i].velocity.xyz, objects[start + (i + 1) % count].position.xyz, objects[start + (i + 1) % count].velocity.xyz);

        draw(start + i, vec4(hsv2rgb(float(i) / count, 1, 1), 1));

        center_dir += objects[start + i].position.xyz;
    }

    center_dir /= count;

    center_dir -= camera_pos.xyz;

    trace_result result = multi_closest(camera_pos.xyz, 1, start, end);

    draw_relative_point(result.diff, vec4(1));

    result = multi_trace(camera_pos.xyz, FRONT, 5, start, end);

    draw_relative_point(result.diff, vec4(1));

    uint steps = 64;
    float step_size = 2 * PI / steps;

    vec3 horizontal = normalize(cross(center_dir, UP));
    vec3 vertical = normalize(cross(center_dir, horizontal));

    for (float i = 0; i < 2 * PI; i += step_size) {

        vec3 trace_dir = normalize(UP * sin(i) + RIGHT * cos(i));

        for (uint s = 0; s < 4; s++) {
            result = multi_trace(camera_pos.xyz, trace_dir, 5, start, end);

            draw_relative_point(result.diff, vec4(hsv2rgb(result.distance, 1, 1), 1));

            trace_dir += result.diff * 0.1;
        }
    }
}

void main() {
    if (gl_WorkGroupID.x == 0 && gl_WorkGroupID.y == 0 && gl_WorkGroupID.z == 0) {
//        draw_relative_point(LEFT, vec4(0, 1, 1, 1));
//        draw_relative_point(RIGHT, vec4(0, 1, 1, 1));
//        draw_relative_point(DOWN, vec4(0, 1, 1, 1));
//        draw_relative_point(UP, vec4(0, 1, 1, 1));
//        draw_relative_point(FRONT, vec4(0, 1, 1, 1));
//        draw_relative_point(NORTH, vec4(0, 1, 1, 1));
//
//        draw_line(view_center, view_center + ivec2(10, 0));
//        draw_line(view_center, view_center + ivec2(-10, 0));
//        draw_line(view_center, view_center + ivec2(0, 10));
//        draw_line(view_center, view_center + ivec2(0, -10));

//        float step_size = 0.1;

//        for (float t = 0; t < 1; t += step_size) {
//            draw_relative_point(FRONT + TO_LEFT * t, vec4(hsv2rgb(t, 1, 1), 1));
//            draw_relative_point(FRONT + TO_RIGHT * t, vec4(hsv2rgb(t, 1, 1), 1));
//            draw_relative_point(FRONT + TO_DOWN * t, vec4(hsv2rgb(t, 1, 1), 1));
//            draw_relative_point(FRONT + TO_UP * t, vec4(hsv2rgb(t, 1, 1), 1));
//        }
//
//        for (uint i = 0; i < 100; i++) {
//            draw_world_point(fibonacci_sphere(i, 100), vec4(hsv2rgb(i / 100., 1, 1), 1));
//        }

//        draw_arc(LEFT_PIXEL, ivec2(LEFT_PIXEL.x, DOWN_PIXEL.y) - LEFT_PIXEL, DOWN_PIXEL, ivec2(LEFT_PIXEL.x, DOWN_PIXEL.y) - DOWN_PIXEL);
//        draw_arc(LEFT_PIXEL, ivec2(LEFT_PIXEL.x, UP_PIXEL.y) - LEFT_PIXEL, UP_PIXEL, ivec2(LEFT_PIXEL.x, UP_PIXEL.y) - UP_PIXEL);
//
//        draw_arc(RIGHT_PIXEL, ivec2(RIGHT_PIXEL.x, DOWN_PIXEL.y) - RIGHT_PIXEL, DOWN_PIXEL, ivec2(RIGHT_PIXEL.x, DOWN_PIXEL.y) - DOWN_PIXEL);
//        draw_arc(RIGHT_PIXEL, ivec2(RIGHT_PIXEL.x, UP_PIXEL.y) - RIGHT_PIXEL, UP_PIXEL, ivec2(RIGHT_PIXEL.x, UP_PIXEL.y) - UP_PIXEL);
//
//        draw_line(LEFT_PIXEL, DOWN_PIXEL);
//        draw_line(LEFT_PIXEL, UP_PIXEL);
//        draw_line(RIGHT_PIXEL, DOWN_PIXEL);
//        draw_arc(LEFT_PIXEL, ivec2(0, -1), DOWN_PIXEL, ivec2(-1, 0));
//        draw_line(DOWN_PIXEL, RIGHT_PIXEL);
//        draw_line(RIGHT_PIXEL, UP_PIXEL);
//
//        draw_line(ivec2(LEFT_PIXEL.x, DOWN_PIXEL.y), ivec2(RIGHT_PIXEL.x, DOWN_PIXEL.y));
//        draw_line(ivec2(LEFT_PIXEL.x, UP_PIXEL.y), ivec2(RIGHT_PIXEL.x, UP_PIXEL.y));
    }

    uint self = gl_WorkGroupID.x;
    uint other = gl_WorkGroupID.y;

    if (self == other && (objects[self].state & SHOW) != 0) {
        draw_world_line(objects[self].position.xyz, objects[self].position.xyz + objects[self].velocity.xyz);
        draw_world_line(objects[self].position.xyz + objects[self].velocity.xyz, objects[self].position.xyz + objects[self].velocity.xyz + objects[self].acceleration.xyz);

//        if ((objects[self].state & CONNECTED) != 0) {
//            if (objects[self].prev == self) {
//                uint end = self;
//                while (objects[end].next != end) {
//                    end = objects[end].next;
//                }
//
//                draw_connection(self, end);
//            }
//        }
//        else {
//            draw(self, vec4(hsv2rgb(float(self) / gl_NumWorkGroups.x, 1, 1), 1));
//        }
    }

    if (self < other && (objects[self].state & SHOW) != 0 && (objects[other].state & SHOW) != 0) {
//        draw_world_line(closest_point(objects[other].position.xyz, self), closest_point(objects[self].position.xyz, other));
    }
}
