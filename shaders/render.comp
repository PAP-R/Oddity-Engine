#version 450 core

#include <buffer.glsl>
#include <object.glsl>

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2DArray texture;

layout(std140, std430, binding = RENDER) buffer render_buffer {
    vec4 camera_pos;
    mat4 vp;
    ivec2 view_size;
    uint layer;
};

vec3 FRONT_BASE = normalize(vec3(0, 0, -1));
vec3 LEFT = ((vp * vec4(normalize(vec3(-1, 0, 0) + FRONT_BASE), 1)).xyz);
vec3 LEFT_DIR = normalize(LEFT);

vec3 RIGHT = ((vp * vec4(normalize(vec3(1, 0, 0) + FRONT_BASE), 1)).xyz);
vec3 RIGHT_DIR = normalize(RIGHT);

vec3 TO_RIGHT = RIGHT - LEFT;
vec3 DOWN = ((vp * vec4(normalize(vec3(0, -1, 0) + FRONT_BASE), 1)).xyz);
vec3 DOWN_DIR = normalize(DOWN);

vec3 UP = ((vp * vec4(normalize(vec3(0, 1, 0) + FRONT_BASE), 1)).xyz);
vec3 UP_DIR = normalize(UP);

vec3 TO_UP = UP - DOWN;
vec3 FRONT = ((vp * vec4(FRONT_BASE, 1)).xyz);
vec3 FRONT_DIR = normalize(FRONT);

ivec2 LEFT_PIXEL = ivec2(vec2(dot((LEFT_DIR - LEFT), normalize(TO_RIGHT)) / length(TO_RIGHT), dot((LEFT_DIR - DOWN), normalize(TO_UP)) / length(TO_UP)) * (view_size - ivec2(1)));
ivec2 RIGHT_PIXEL = ivec2(vec2(dot((RIGHT_DIR - LEFT), normalize(TO_RIGHT)) / length(TO_RIGHT), dot((RIGHT_DIR - DOWN), normalize(TO_UP)) / length(TO_UP)) * (view_size - ivec2(1)));
ivec2 DOWN_PIXEL = ivec2(vec2(dot((DOWN_DIR - LEFT), normalize(TO_RIGHT)) / length(TO_RIGHT), dot((DOWN_DIR - DOWN), normalize(TO_UP)) / length(TO_UP)) * (view_size - ivec2(1)));
ivec2 UP_PIXEL = ivec2(vec2(dot((UP_DIR - LEFT), normalize(TO_RIGHT)) / length(TO_RIGHT), dot((UP_DIR - DOWN), normalize(TO_UP)) / length(TO_UP)) * (view_size - ivec2(1)));

ivec2 dir_to_pixel(vec3 dir) {
    dir = normalize(dir);
    vec2 ratio = vec2(dot((dir - LEFT), normalize(TO_RIGHT)) / length(TO_RIGHT), dot((dir - DOWN), normalize(TO_UP)) / length(TO_UP));

    ivec2 result = ivec2(ratio * (view_size - ivec2(1)));

    if (!(dot(cross(LEFT_DIR, dir), cross(LEFT_DIR, RIGHT_DIR)) >= 0 && dot(cross(RIGHT_DIR, dir), cross(RIGHT_DIR, LEFT_DIR)) >= 0)) {
        if (result.x < (view_size.x / 2)) {
            result.x = 2 * LEFT_PIXEL.x - result.x;
        }
        else {
            result.x = 2 * RIGHT_PIXEL.x - result.x;
        }
    }
    if (!(dot(cross(DOWN_DIR, dir), cross(DOWN_DIR, UP_DIR)) >= 0 && dot(cross(UP_DIR, dir), cross(UP_DIR, DOWN_DIR)) >= 0)) {
        if (result.y < (view_size.y / 2)) {
            result.y = DOWN_PIXEL.y - result.y;
        }
        else {
            result.y = 2 * UP_PIXEL.y - result.y;
        }
    }

//    return ivec2(ratio * (view_size - ivec2(1)));
    return result;
}

vec3 pixel_to_dir(ivec2 pixel) {
    vec2 ratio = pixel / view_size;

    return normalize(LEFT + TO_RIGHT * ratio.x + DOWN + TO_UP * ratio.y);
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void draw_point(ivec2 pos, vec4 color) {

    if (0 <= pos.x && pos.x < view_size.x && 0 <= pos.y && pos.y < view_size.y) {
        imageStore(texture, ivec3(pos, layer), color);
    }
}

void draw_relative_point(vec3 pos, vec4 color) {
    draw_point(dir_to_pixel(pos), color);
}

void draw_world_point(vec3 pos, vec4 color) {
    draw_point(dir_to_pixel(pos - camera_pos.xyz), color);
}

void draw_line(ivec2 start, ivec2 end) {
    float dist = distance(start, end);
    vec2 dir = normalize(vec2(end - start));

    for (float i = 0; i < dist; i++) {
        draw_point(start + ivec2(dir * i), vec4(hsv2rgb(vec3(i / dist, 1, 1)), 1));
    }
}

void draw_arc(ivec2 start, ivec2 start_dir, ivec2 end, ivec2 end_dir) {
    float dist = distance(start, end);
    vec2 dir = normalize(vec2(end - start));

    for (float t = 0; t <= 1; t += 0.025) {
        draw_point(ivec2((start + start_dir * (1 - t))), vec4(hsv2rgb(vec3(t, 1, 1)), 1));
        draw_point(ivec2((start + (dir * t * dist) + start_dir * (1 - t)) + (end_dir * t)), vec4(hsv2rgb(vec3(t, 1, 1)), 1));
        draw_point(ivec2((end + end_dir * t)), vec4(hsv2rgb(vec3(t, 1, 1)), 1));
    }
}

void draw_world_line(vec3 start, vec3 end) {
    draw_line(dir_to_pixel(start - camera_pos.xyz), dir_to_pixel(end - camera_pos.xyz));
}

float line_step = 0.01;

void draw(uint obj, vec4 color) {
    uint steps = 64;
    float step_size = 2 * PI / steps;

    vec3 center_dir = objects[obj].position.xyz - camera_pos.xyz;
    vec4 result = trace(camera_pos.xyz, center_dir, 2, obj);
    draw_relative_point(result.xyz, color);

    vec3 para = normalize(cross(center_dir, UP));
    vec3 patam = normalize(cross(center_dir, para));

    for (float i = 0; i < 2 * PI; i += step_size) {

        float dist = length(center_dir);

        for (uint s = 0; s < 10; s++) {

            vec3 spup = normalize((para) * sin(i) + (patam) * cos(i));
            vec4 resulte = closest_point(spup + objects[obj].position.xyz, obj);
//            vec4 resulte = trace_point(camera_pos.xyz, spup + objects[obj].position.xyz, 2, obj);

            dist -= resulte.w / 2;

            draw_world_point(resulte.xyz, color);
        }

        //            vec3 dir = normalize(center_dir + FRONT + (TO_RIGHT) * sin(i) + (TO_UP) * cos(i));
        //            result = trace(camera_pos.xyz, dir, 4, gl_WorkGroupID.x);
        //
        //            draw_relative_point(result.xyz, vec4(hsv2rgb(vec3(mod(length(result.xyz) / length(center_dir), 1), 0.5, 1)), 1));

    }

}

void draw_connection(uint start, uint end) {
    uint count = end - start + 1;

    vec3 center_dir;

    for (uint i = 0; i < count; i++) {
        draw(start + i, vec4(1));
        draw_world_line(objects[start + i].position.xyz, objects[start + (i + 1) % count].position.xyz);

        center_dir += objects[start + i].position.xyz;
    }

    center_dir /= count;

    center_dir -= camera_pos.xyz;

    vec4 result = multi_closest(camera_pos.xyz, 1, start, end);

    draw_relative_point(result.xyz, vec4(1));

    result = multi_trace(camera_pos.xyz, FRONT_DIR, 5, start, end);

    draw_relative_point(result.xyz, vec4(1));

    uint steps = 64;
    float step_size = 2 * PI / steps;

    vec3 horizontal = normalize(cross(center_dir, UP));
    vec3 vertical = normalize(cross(center_dir, horizontal));

    for (float i = 0; i < 2 * PI; i += step_size) {

        float dist = 0.1;

        for (uint s = 0; s < 4; s++) {
            vec3 trace_dir = normalize(center_dir * dist + UP_DIR * sin(i) + RIGHT_DIR * cos(i));
            result = multi_trace(camera_pos.xyz, trace_dir, 5, start, end);

            if (result.w > 0) {
                dist += result.w * 0.1;
            }
            else {
                dist -= 1;
            }

            draw_relative_point(result.xyz, vec4(hsv2rgb(vec3(result.w, 1, 1)), 1));
        }
    }
}

void main() {
    if (gl_WorkGroupID.x == 0 && gl_WorkGroupID.y == 0 && gl_WorkGroupID.z == 0) {
        draw_relative_point(LEFT, vec4(0, 1, 1, 1));
        draw_relative_point(RIGHT, vec4(0, 1, 1, 1));
        draw_relative_point(DOWN, vec4(0, 1, 1, 1));
        draw_relative_point(UP, vec4(0, 1, 1, 1));
        draw_relative_point(FRONT, vec4(0, 1, 1, 1));
        draw_relative_point(FRONT_BASE, vec4(0, 1, 1, 1));

        draw_arc(LEFT_PIXEL, ivec2(LEFT_PIXEL.x, DOWN_PIXEL.y) - LEFT_PIXEL, DOWN_PIXEL, ivec2(LEFT_PIXEL.x, DOWN_PIXEL.y) - DOWN_PIXEL);
        draw_line(DOWN_PIXEL, RIGHT_PIXEL);
        draw_line(RIGHT_PIXEL, UP_PIXEL);
        draw_line(UP_PIXEL, LEFT_PIXEL);
    }

    uint self = gl_WorkGroupID.x;
    uint other = gl_WorkGroupID.y;

    if (self == other && (objects[self].state & SHOW) != 0) {
        if ((objects[self].state & CONNECTED) != 0) {
            if (objects[self].prev == self) {
                uint end = self;
                while (objects[end].next != end) {
                    end = objects[end].next;
                }

                draw_connection(self, end);
            }
        }
        else {
            draw(self, vec4(hsv2rgb(vec3(float(self) / gl_NumWorkGroups.x, 1, 1)), 1));
        }
    }

    if (self < other && (objects[self].state & SHOW) != 0 && (objects[other].state & SHOW) != 0) {
//        draw_world_line(closest_point(objects[other].position.xyz, self), closest_point(objects[self].position.xyz, other));
    }
}
