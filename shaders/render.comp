#version 450 core

#include <buffer.glsl>
#include <object.glsl>

#define PI 3.1415926535897932384626433832795

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2DArray texture;

struct render_struct {
    vec4 camera_pos;
    mat4 vp;
    vec2 view_size;
    uint layer;
};

layout(std140, std430, binding = RENDER) buffer render_buffer {
    render_struct render;
};

vec3 FRONT_BASE = normalize(vec3(0, 0, -1));
vec3 LEFT = ((render.vp * vec4(normalize(vec3(-1, 0, 0) + FRONT_BASE), 1)).xyz);
vec3 RIGHT = ((render.vp * vec4(normalize(vec3(1, 0, 0) + FRONT_BASE), 1)).xyz);
vec3 DOWN = ((render.vp * vec4(normalize(vec3(0, -1, 0) + FRONT_BASE), 1)).xyz);
vec3 UP = ((render.vp * vec4(normalize(vec3(0, 1, 0) + FRONT_BASE), 1)).xyz);
vec3 FRONT = ((render.vp * vec4(FRONT_BASE, 1)).xyz);

ivec3 to_pixel(vec3 dir) {
    dir = normalize(dir);
    return ivec3(vec2(dot(dir - LEFT, normalize(RIGHT - LEFT)) / distance(LEFT, RIGHT), dot(dir - DOWN, normalize(UP - DOWN)) / distance(DOWN, UP)) * render.view_size, render.layer);
}

int point_size = 250;

void main() {
    Object self = objects[gl_WorkGroupID.x];

    if ((self.state & SHOW) > 0) {
        vec3 dir = self.position.xyz - render.camera_pos.xyz;
        if (dot(dir, FRONT) > 0) {
            float radius = self.test_value.x;

            float len = length(dir);

            vec3 left_test = cross(dir, DOWN) * len + dir;
            vec3 right_test = cross(dir, UP) * len + dir;
            vec3 down_test = cross(dir, LEFT) * len + dir;
            vec3 up_test = cross(dir, RIGHT) * len + dir;

            ivec3 left_pixel = to_pixel(closest(render.camera_pos.xyz + left_test, gl_WorkGroupID.x) + left_test - render.camera_pos.xyz);
            ivec3 right_pixel = to_pixel(closest(render.camera_pos.xyz + right_test, gl_WorkGroupID.x) + right_test - render.camera_pos.xyz);
            ivec3 down_pixel = to_pixel(closest(render.camera_pos.xyz + down_test, gl_WorkGroupID.x) + down_test - render.camera_pos.xyz);
            ivec3 up_pixel = to_pixel(closest(render.camera_pos.xyz + up_test, gl_WorkGroupID.x) + up_test - render.camera_pos.xyz);

            int left = min(left_pixel.x, right_pixel.x);
            int right = max(left_pixel.x, right_pixel.x);
            int down = min(down_pixel.y, up_pixel.y);
            int up = max(down_pixel.y, up_pixel.y);

            ivec3 center = to_pixel(dir);

            int point_width = (right - left) / 2;
            int point_height = (up - down) / 2;

            int horizenter = (left + right) / 2;

            if (center.z >= 0) {
                for (int x = left; x < right; x++) {
                    int circle = point_height - abs(int(point_height * cos(asin(float(x - horizenter) / point_width))));
                    for (int y = down + circle; y <= up - circle; y++) {
                        ivec3 pixel = ivec3(x, y, center.z);
                        if (0 <= pixel.x && pixel.x < render.view_size.x && 0 <= pixel.y && pixel.y < render.view_size.y) {
                            imageStore(texture, pixel, vec4(vec2(pixel.xy) / render.view_size.xy, 0, 1));
                        }
                    }
                }
            }
        }
    }
    memoryBarrier();
}
